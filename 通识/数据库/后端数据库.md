# 后端数据库补充知识

如果你已经看过了前文的描述，这里就是一些关于后端数据库的补充知识。

后端里面用到的数据库都是一些大型数据库，相对来讲功能很多，支持完善，如果没有特殊说明，以下的一些说明都是根据mysql的特性来订立的，因为mysql目前仍是我们公司内最常用的数据库（虽然我非常想把它换成Pg，但是无奈云数据库服务商里Pg的售价比mysql贵太多）

## 关于建库

毕竟大型数据库的储存与处理能力都相对强大，因此，相对于前端数据库的捉襟见肘而言，后端数据库反而应该更多地考虑灵活性和拓展性，以备未来不时之需

### 1，预留充足的主键

对于一些常见的系统而言，如果设置主键的类型为uint32，那么其容量上限为42亿，虽然对于绝大多数系统来讲是足够用的，但是在某些特殊的场景或需求下，它可能是不够用的。例如保存聊天数据、日志数据等等，它们很可能分分钟超过42亿。

### 2，警惕统计过程中的数据溢出

假设某一个字段的数据类型是int32，单纯保存某一行的数据是足够用的，但是对它进行求和运算的时候，很有可能求和的值会超出int32的范围，这个在一些交易系统或订单系统中会经常碰到。因此，我们十分推荐用int64或uint64来保存跟钱有关的字段，以保证它很难溢出。

### 3，严格控制数据大小

当涉及字符串的储存的时候，很多人会默认VARCHAR 255，这实际上不是一个好的解决方案，具体得看保存的内容。假定是拿来保存一个手机号的，那么就根本没必要长度255。同样的道理，假如是存储一个UUID的时候，就更加应该控制为CHAR 36或者CHAR 32类型，因为UUID的大小是确定的。

严格控制数据的大小一方面可以帮我们防止一些bug，也可以提高某些字段的查询性能（尤其是字符串类型）

### 4，谨慎设计数据库关系

在很多教程中，很多老师会无意间提到级联这个概念，甚至会很多时候推荐大家用级联更新这样的特性。但实际上这样的操作是有隐患的，我举一个例子：有两张表，第一张表是客户，第二张表是订单，其中，一个客户可以有若干个订单。

#### 级联更新是正确的

当然，绝大多数情况下，级联“更新”是正确的，因为更新客户信息后，通过订单关联查询到的客户信息也会更新，这个是一个非常好的操作。

#### 级联删除非常可怕

但是可怕之处在于级联“删除”，假定删除一个客户之后，这个客户关联的所有订单信息将会在无提醒的情况下删除。很多时候这个在统计系统里面将会是灾难，比如说我要统计这个月的订单KPI的时候，很显然这个时候就发生Data Lost了。那么既然级联删除非常可怕，有什么替代方案呢？

主要是两个：SET NULL或者RESTRICT。在刚刚的场景下，SET NULL能够保证客户删除后，订单信息并不删除，只是找不到相关的客户而已，那么就起码能保证统计的数字是准确的。同样的场景，RESTRICT则是保证，在没有条目引用这个数据后才可删除，那么也就是说，我可以自定义一套逻辑，对用户的所有订单进行判断，判断符合删除条件后，才进行删除。

这两个解决方案针对不同的应用场景和需求，灵活判断即可，总而言之就是，千万不能随便乱设置级联删除。

## 数据库逻辑安全

在之前的描述中提到了SQL注入相关的安全问题，此处额外补充一系列的数据库逻辑引发的漏洞

### 1，严禁明文保存敏感数据

有的系统中设计了用户名与密码登录，那么如果把密码明文保存在数据库中将是非常可怕的行为。业内常见的处理方案基本上就是加盐哈希，我们常见的加盐哈希有如下两种实现方式：

```js
// 这里的是伪代码，理解意思即可
// 方案1，拼接hash，这样可以抵挡彩虹表攻击，但是这样的方案依旧可能有被暴力破解的可能
const raw = '123456'
let hash = sha256(raw).toString()
let result = sha256(raw.toUpper() + hash.toLower()) // 这样混淆过后的情况下，基本上已经很难爆破了，但是这个算法的问题在于，一旦你混淆的手段泄漏了（比如说公司内鬼，或者是被反编译了）这个算法就逃不过彩虹表的爆破了，于是乎有了第二种解决方案

// 方案2，直接使用BCrypt，有大把现成库可以调用
```

### 2，严禁“外部”通过Id进行查询

之前我们讲过，数据库需要一个自增int类型主键，用于帮我们形成顺序。这固然很好，但是我们不能在“外部”通过id进行查询。所谓的“外部”，就是指从别的地方获取到一个id，然后进行查询，比如说在web后端里，有一个接口：

``` http
https://my.domain.com/api/user/getInfo?userId=10086
```

也就是说，程序要接收一个外部输入id进行查询，这种情况下，是非常危险的。我只需要随便写一个脚本，从1开始扫，就把你数据库里面所有的userInfo全部给撬出来了，这种情况称之为“拖库”。

当然，特别注意我说的定语，“外部”通过id进行查询。如果你这个id是一个可信源出来的，那么这样查询没毛病，反而效率是最高的。那么如果我非得通过id来进行查询的时候，我应该怎么办呢？请移步到后端接口的设计规范中，其中专门讲述了这种情况的安全处理办法。