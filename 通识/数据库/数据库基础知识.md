# 数据库基本常识

这些知识无论你是否从事与数据库相关的开发工作，你都应该知道。推荐所有从业人员查看。

无论是在前端还是后端，如果需要保存大量数据并进行查询的时候，数据库是一个非常重要的组件。一般而言，数据库的主要数据类型包括字符串、时间、数字、二进制以及其衍生类型（例如json，uuid等等）一般而言，数据库保存的数据都是结构化的，而且需要进行合理有效地组织以进行高效率查询。

## 建库规范

建立一个数据库表需要遵循一定的规范，其中一部份规范是有利于提高数据库性能的还有一部份则是一些我们公司内部的硬性规定。

### 1，数据库必有主键，且主键必须是自增长整数

设立这个规范的最主要原因，是为了保证数据库数据的有序性以及插入的速度。至于是int32, uint32, int64还是uint64，就根据各自的业务规模进行估算即可，一般而言，我们常用的还是uint32和uint64为主。早些年的系统经常使用UUID作为主键，虽然可以很好避免重复的问题，但是UUID本身没有顺序性（也不是不可以有，但是得用特殊的生成方法，且在分布式环境下仍然容易出现乱序的问题），因此为了更加方便查看数据库的数据新增以及大致的时间序列，自增长整数就是一个最简单且最有效的方案了。

### 2，尽量避免大对象（例如longtext等等）

当然，这个不一定需要遵守，因为某些数据库（比如说Pg）可能对这类对象有非常好的优化，反而可以省心地使用longtext。因为数据库存储引擎的组织问题，这类型的大对象往往不是顺序储存在树的节点上，而是通过指针指向另一块空间相对更自由的，保存了这个数据的地方。因为一些早期数据库的设计问题，这些大对象往往会减慢查询的速度，并且由于存储分布的问题，可能会引起磁盘的碎片或空洞问题，进而导致更加严重的性能问题。

当然，上述的东西，并不是100%的规律，因此要看不同数据库的特性和版本，目前新版的数据库基本上都慢慢解决掉了这些问题。

### 3，严禁使用32位时间戳

由于2038年问题，我们在任何时候都不应该使用32位的数据来保存毫秒时间戳，转而应该使用新的类型，例如mysql datetime等等。具体的操作要看不同的数据库而定。

### 4，时间类型严禁混淆时区

数据库对时区数据的支持各有不同，例如Pg数据库是将timestamp和timezone分开储存，因此可以支持非常准确的时间戳查询。然而mysql的datetime类型往往不处理时间的问题，因此可能导致一系列的问题。因此，如果是用到了某些对时区特性支持比较模糊的数据库，我们必须强行约定：一律使用UTC时间进行增删改查，再由外部程序完成和本地时间的转换。

### 5，谨慎使用索引（unique除外）

数据库字段的unique往往是靠索引完成的，因此不在此处的考虑范围内，如果业务要求不重复的字段，用就完事了。

建立索引是会占用磁盘空间的，因此，除非是需要频繁查询的热点数据，没有必要建立索引。

除此之外，索引也分正序索引与倒序索引，特别注意时间类型，因为很多时候我们会面临按时间先后顺序进行排序的需求，而很多时候时间往往是作为一个从大到小的规则进行排序的，因此，如果不慎设立了一个ASC的索引，是没有任何帮助的。

## 安全问题

数据库主要堤防三方面的安全问题：分别是连接安全、SQL安全、逻辑安全。

### 连接安全/数据库安全

现代的数据库基本上都有用户系统以及权限系统，那么，为每个服务配置特定的用户名、复杂密码、权限是非常必要的，并且不能将数据库连接随意暴露在公网。

如果是SQLite之类的文档数据库，那也起码要使用AES加密的手段保障数据库文件的安全。

### SQL安全

此处就是大名鼎鼎的SQL注入问题，是一个非常经典的网络攻击。我们在此处不过多赘述关于这方面的知识，但是强行立下若干个规定：

#### 1，严禁直接拼接SQL字符串

特别是like查询，因为like查询难免需要给查询关键词添加上%进行匹配，这就给了很多SQL注入可乘之机。基本上主流的编程语言，都有相对应的字符串模板用于拼接相关语句，而不是直接操作语言的字符串。

#### 2，严禁不通过ORM框架进行查询/或利用ORM进行RawSQL查询

ORM框架基本上都有对应的防注入手段，因此，与其控制自己团队成员的水平，不如全权委托给专门的框架处理。

#### 3，业务数据库连接权限必须限制

假如如上的手段都无法避免SQL注入攻击，那么，合理的连接配置，就是减少损失的最后一根救命稻草。例如，限制当前连接用户的Drop Table，CreateTable等等权限。

### 逻辑安全

此处不细讲，请移步后端补充说明。