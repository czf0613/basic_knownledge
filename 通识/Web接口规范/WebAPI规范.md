此章节非常非常重要，请一定要仔细仔细阅读！！！这个将是我们所有web服务中最最最基础的通识内容。

首先请确定你已经完全熟知http协议的基础知识，否则你会完全看不懂这个章节的内容。

# Http Web API接口规范

## 请求体数据从何而来

Http协议的形式有非常多，但是不意味着我们会在代码中启用所有的特性，毕竟会把很多代码搞乱。而且我们这里提到的形式一般只考虑请求体的形式，因为基本上我们默认Response永远都只关心请求体，不会关心别的形式到来的数据（但是这话不绝对，有某些特殊情况下是要考虑的）

首先梳理一下Http请求中，传递数据的几个经典来源：

### FromQuery

这是最常见的一种形式，也就是把参数直接拼接进去url里面进行传输。一般而言会出现在GET请求中。但是这种形式的限制非常大，我们后面会详细说明这个要怎么用。

### FromPath

将参数作为路径的一部分进行请求。我们不应该使用这种方式，具体原因后面说。

### FromHeader

顾名思义，就是从http请求头中获取数据，一般来讲应用在获取token、或者一些特殊的字段。

### FromBody

这个也是非常常见的形式，通过json字符串将数据通过http的请求体进行发送，在绝大多数的后端api中，我们都是使用这样的形式进行数据传输。

### FromForm

使用表单的形式提交数据，一般而言是用来提交字符串或者FormFile的。这种请求的形式一般相对少见，除非是要提交文件的时候会偶尔出场一下。我们不太建议使用这种方案的根本原因还是文件传输，我们后面会专门提及关于文件处理的问题。

### *FromBinary

还有一种极其不建议使用的方式，也就是从请求体中直接读取二进制内容。除非极其特殊的需求，我们坚决不应该使用这个方式（后面会解释）。

### 互斥

上述的三种跟请求体有关的传输方式，也就是json，form，binary这三种，在一个请求中只能任选其一。一个http请求不可能同时有json和form两种，而binary则会以二进制的形式读取请求体的内容，而不会关心到底是json还是form。所以在设计参数的时候，切记容易出现冲突。



## 请求形式与注意点

因为http协议本身的一些特性，因此上面所列举的这些请求方式，各自都存在很多的长处和短处，所以并没有什么万金油的解决方案，一切需要根据当前功能灵活变通。

### FromQuery

从url参数中传递数据是最简单的方式，但是，因为某些浏览器可能对url长度有限制，因此并不适合传输比较长的字符串或者内容。而且有一个最严重的问题，也就是编码问题。URL只支持纯英文字符，并且很多字符在url中是有特殊含义的，随意拼接字符串很可能导致意外的结果。因此此处做出一个强行规定：

#### 参数强制urlencode

虽然在绝大多数的英文字符情况下并不需要urlencode，但我依然强烈建议进行编码，冷不丁出现的一些字符，比如说问号，加号很可能会对url造成破坏性的结果。因此，如果在需要使用到字符串（不管是输入什么内容的）、或者可能数字会出现正负号，小数点的时候，无论如何必须进行urlencode！！！

例如我需要发起这样的一个请求，其中的name字段可能有非英文字符，而pid字段是一个整数。

``` http
GET /api/user/getUserInfo?name=xxxxx&pid=123456
```

因为我们无法确认name字段中是否会出现转义字符。（千万不要相信用户的输入，你永远不知道用户会给你整什么活）因此，在构造请求的时候，需要特别注意：

``` javascript
// 千万不要用这个方式！容易出事情
const dangerousUrl = `https://www.domain.com/api/user/getUserInfo?name=${name}&pid=${pid}`;

// 这样做就会安全很多
// 这样做起码保证name字段一定不会引起歧义，至于pid，可以通过前端控制它为number类型来一定程度上避免问题
const safeUrl = `https://www.domain.com/api/user/getUserInfo?name=${encodeURIComponent(name)}&pid=${pid}`;
```

#### 慎用！

也正因为这个urlencode的问题，所以FromQuery的限制条件是比较多的，一般情况下，除非是意义很明确的GET请求，或者是参数极为简单的DELETE请求，一般情况下不要使用FromQuery传递参数。

### FromPath

~~别跟我扯什么REST风格，你说就是你对，啊对对对。~~

#### 严禁使用！

这个是前面提到的，我们特别反对使用的一个传递参数的方式，我们无论如何禁止在API中使用这个方式传递参数。原因有如下几点：

1，还是urlencode的问题，而且它的问题会比从query中传递参数更多，并且如果某个转义字符串特别长的时候，这个url的可读性将会非常差，比如说这样：

``` http
// 1，接口的定义如下
GET /api/user/{userName}/info

// 那么，如果某个用户的用户名特别离谱的时候，会搞出来一个这样的请求
GET /api/user/%E5%AE%87%E5%AE%99%E6%97%A0%E6%95%8C%E6%9C%80%E9%9D%93%E6%9C%80%E5%B8%85%E7%9A%84%E4%BB%94/info
```

这样的请求路径，无论是你在debug的时候……还是在检查日志的时候，都一定会头大无比……

2，表意不清。因为省掉了参数名称，从而会导致这个参数的含义被丢失，我举个例子：

``` http
GET https://www.domain.com/api/user/13717421
```

你很难从url中一下子知道13717421是什么意思，是userId吗？还是手机号码？还是什么特殊的记号？

3，最大的问题在于干扰路由。因为这里很可能涉及到模式匹配甚至是正则匹配的问题，绝大部分web server的设计都是贪婪匹配，如果用户输入了一个没有经过恰当转义（就哪怕转义了，也可以搞事情，看我下面的例子），或者是恶意攻击者恶意构造的一个路径，这个杀伤力将会非常大，举一个不恰当的例子来说：

``` http
// 1, 第一个接口是拿来查询用户信息的，有一个路径参数，要填写string类型的用户名
GET /api/user/{userName}

// 2，这个接口是拿来登陆的
POST /api/user/login

// 那么假设此时，如果我恰好有一个用户的用户名就叫"login"的话，将会发生非常好玩的事情，对吧
```

### FromBody

我们这里提到的都特指json字符串（不考虑别的类型，因为json是最通用的）json字符串的通用性特别强，基本上没有什么特别大的槽点，唯一需要注意的，就是数据类型的问题，因为json毕竟是基于javascript语言，这一点我们会在后面的接口设计规范中详细说明。

### FromForm & FromBinary

这两个放在一起说，因为用到这两个的时候，基本上都意味着你要搞文件上传或者要上传一些二进制的内容上来了。文件上传是一个非常危险的行为，因为用户可能给你搞点病毒或者搞点奇怪的东西进来，所以我们一旦遇到需要进行文件上传的时候，请马上使用公司里面研发的KCos框架。

#### 避免使用！

如果你很确定你不是拿来搞文件上传之类的高危操作的时候，可以考虑使用一下Form或者Binary，但是也尽可能避免会比较好，因为这俩都相对来说请求体会比较大，如果不做优化，会给服务器内存造成比较大的问题，因此处于性能的考虑，尽量避免使用。



## API接口设计规范

### /api前缀

绝大多数时候，我们的API服务都藏在网关的背后，因此网关需要根据一定的规则进行转发。而其中最简单的方式就是匹配路径的前缀。

那么我们就在此处强行约定，http web api一律必须以/api打头，例如/api/user/login，/api/photos/download等等。

### 数据类型问题

这个问题比较看应用场景，主要看发送方和接收方的类型，针对不同的场景会有不同的选择，以下的也只是一些我们的“经验”而已。如果你很确定相互通信的两个平台绝对不会遇到相关问题的时候，你可以忽略我下面的警告。

#### js number类型溢出

因为json这个数据类型很大概率会跟js打交道，比如说浏览器或者等等环境。因为js底层的数字类型是double，也就是说不管是整数还是浮点也好，都被当成double来储存。那么，如果后端返回的数字是一个很大的int64或者uint64的时候，是有概率会超过number类型的上限的。

这种问题相对来说比较好解决，首先一个，如果你很明确不会跑到浏览器之类的平台的话，就放心大胆用吧；如果必须得使用js的话，我们可以在后端的json序列化器配置一个选项，使用WriteNumberAsString，这样起码保证在数据传输过程中是正确的，然后剩下的交给js使用大整数相关的库就可以解决问题，市面上有很多解决方案。

#### jvm下unsigned类型溢出

众所周知jvm下是没有unsigned类型的，如果我们在json中，定义了uint32或者uint64数据类型的时候，用Java int去接uint32很可能会在Java中发生溢出。这个问题也很好解决，有如下解决方案：

比如说将Java里面对应的数据类型换为高一级的类型，比如说用Java long去接住uint32的值，用BigInteger去接住uint64的值。当然，前提是你使用的序列化框架要支持BigInteger和BigDecimal的序列化，否则也会出问题。

#### 字节数组、二进制类型

按照我们之前说的，除非某些极其特殊的需求之外，不应该用任何形式在请求中携带二进制数据（包括base64等等），之前已经解释过很多遍了，一般你在使用到这些类型的时候，基本意味着你已经在尝试上传文件了，这是非常危险的操作。

#### 时间

按照我们约定的规范，任何涉及时间的字段，都一律使用ISO8601格式的时间戳，以避免时区引起的问题。但是这个话不绝对，如果有一些情况下我们只需要DateOnly或者TimeOnly的情况下，我们使用"yyyy-MM-dd"的格式表示日期，用"HH:mm:ss"的格式表示时间，后端就可以非常方便地解析。

#### 某些类型并非能用json表达

json看起来是很灵活，但是有很多的数据类型很难用json进行表达，比如说字节数组，往往需要用base64转一手才能表达。不过，按照我们的开发规范，是严格禁止传输二进制对象的。

Set类型，是无法用json准确表达的。绝大部分的编程语言做json序列化的时候，会自动把Set转换成一个数组的形式进行表达，而数组并没有保证元素不重复的能力，有概率会在json和语言内建对象互相转换的时候出现错误。

还有一个非常容易忽略的错误，就是Dictionary类型。虽然绝大多数的编程语言都有字典这一个数据结构，但非常不巧，这个在json里面的功能是残的。因为js表达“对象”的方式跟字典实在是过于相似，因此我们尽可能避免在json里面传输字典。其实也不是说就完全不可以用，例如Dictionary<string, any>类型就是可以被json正确转换的，因为这个Dictionary被表示出来的结果正好就是js对象的表示方式，key是字符串类型，正好就被转换成了js对象的key，两者是可以正常互相转换的。



### 接口命名/方法名称

这一块是非常重要的内容，优雅与否就在此一举了。我们大约遵循如下的设计规范：

#### 小驼峰

一般而言，我们遵循小驼峰的命名规范，举个例子：

``` javascript
// 都由一个单词构成
const url1 = "/api/user/login"

// 由两个及以上单词构成
const url2 = "/api/user/getUserInfo"
```

#### “动作”

看上文的url2，其实对于业务来讲，肯定是有对于某个对象的增删改查方法的。~~然而，在某些REST风格盛行的年头，有一些非常走火入魔的写法。~~早年的REST风格，会建议你把上述的url定义为如下的格式：

``` javascript
// ！！！反面教材，莫学
// 查
const getReq = get("/api/user/userInfo/xxxxxx")
// 增
const postReq = post("/api/user/userInfo/xxxxxx", data = { ... })
// 改
const modifyReq = put/patch("/api/user/userInfo/xxxxxx", data = { ... })
// 删
const deleteReq = delete("/api/user/userInfo/xxxxxx")
```

这些数据都从同一个URL进来，根据http请求方法的不同来作出不同的处理。这个想法看起来不错，但是我强行下令禁止这种做法！原因有如下几个：

1，按照我上面所说，我禁止接口用路径参数，因此REST API的先决条件就已经被破坏了。

2，增大犯低级错误的可能性。~~众所周知程序员的精髓就是复制粘贴。~~既然构造这两个请求的代码如此相似，就肯定避免不了在复用这段代码的时候搞出来一些低级错误，比如说明明是要新增记录，结果搞了个GET请求过去。然而这种bug还特别难检查，因为都是一些很细节的粗心大意，不仔细看多几遍是根本不知道哪里出错了的。

那么下列则是正确的解决方案，这么一改是不是瞬间清晰明了多了呢？

``` javascript
// 查
const getReq = get("/api/user/getUserInfo?id=xxxx")
// 增
const postReq = post("/api/user/addUserInfo", data = { ... })
// 改
const modifyReq = put/patch("/api/user/modifyUserInfo", data = { ... })
// 删
const deleteReq = delete("/api/user/removeUserInfo")
```

#### 详细的接口文档

有别于protobuf这种既可以当文档，又可以当代码的高效率表达。http web api往往无法避免非常庞大冗杂的接口文档。千万不要偷懒，不然到时候会惹一堆bug出来。~~要不然你们就用protobuf来约定吧。~~鉴于目前的一些情况，我们以后可能会用protobuf文件来进行api接口的文档约定，但是目前依然还是使用老的方法来进行约定，具体切换时间未定。

我们一般来讲用如下的一个模板来表示一个接口文档：

```http
// 不要管这个userId的设置是否合理，这里只是示例，后面在讲API安全的时候会着重强调
GET /api/user/getUserInfo?userId=xxxx
```

请求参数：

| 参数名称 | 参数位置 | 说明               | 数据类型                                            | 是否必填 | 取值范围     | 示例                                 |
| -------- | -------- | ------------------ | --------------------------------------------------- | -------- | ------------ | ------------------------------------ |
| userId   | query    | 用户的唯一身份标识 | 一个用String表示的UUID，大小写无所谓，用 - 作间隔符 | 是       | 固定长度36位 | de721300-8ac8-4554-8714-fc7668cae1b0 |
| ...      |          | ...                | ...                                                 | ...      | ...          | ...                                  |

返回值：

一个json对象，原型如下

```json
{
  "name": "xxxxx",
  "gender": 0,
  "address": {
    "province": "xxx",
    "city": "",
    "district": ""
  }
}
```

| 参数名          | 数据类型 | 是否必须 | 取值范围  | 说明           |
| --------------- | -------- | -------- | --------- | -------------- |
| name            | String   | 是       | 长度0-255 | 用户的名字     |
| address.provice | String   | 否       | 长度0-20  | 用户住址的省份 |
| ...             | ...      |          | ...       | ...            |

至此，关于API设计的相关问题已解释完毕。



## API安全

早些年有一个机制叫做SSO，也就是所谓的单点登录。原理是靠浏览器的cookie，然后维持一个短时间的会话，只要这个会话还存在，就默认这个用户的登录状态依然存在。但是这么多年过去了，现在的服务早都已经演变成了微服务架构，而且越来越多的平台没有所谓的cookie和session的概念了。究其原因也就是http的无状态化，所以我们需要一个新的手段来保证API的安全。

### 安全机制需要保证：

#### 排他性

也就是说，如果不授权、不登录，就不可以访问某些受限制的资源。任何未授权、或权限不足的用户都不应该提供服务。

#### 时效性

授权并非是永久的，这是为了防止凭证失窃的时候持续造成损失。用户如果需要长期使用，就必须要提供一个续签的机制。

#### 信息签名

授权的令牌不可伪造，别人不可能颁发一个一样有效的令牌给你。同样的道理，如果你使用了令牌进行操作，你也不可以抵赖。这个就起到了信息签名的作用。



### JWT

JWT是一个广泛使用的安全令牌，这里不过多讲述它的生成原理（这个留到后端部分的专题再说）与算法，了解概念即可。JWT由三个部分组成，其中附带了一些必要信息（例如摘要算法、颁发者、有效期、角色等等），还有签名信息。签名信息是用于验证JWT真伪的最重要的部分，签名算法会保证，JWT只能由官方进行签发，并且，如果JWT的附带信息被篡改时，签名算法能立刻发现异常。

JWT通常是搭载在http header的Authorization字段中，这个已经是一个不成文的规矩了。

总结出来JWT的特点就是：

#### 附带必要的信息

可以携带身份信息，这样后端就可以靠解析JWT来知晓是哪个用户。

#### 不可伪造

前提是密钥不能泄漏，泄漏就完犊子了。

#### 不可篡改

附带信息被篡改后，必然导致签名校验失败。



### 怎么设计安全的登录 & 访问

当然，说了这么多，jwt自己就是一个非常非常重要的东西了，一旦泄漏，意味着在jwt失效前的这一段时间内，你的底裤是没有的了。（怎么安全地把jwt保存在电脑里就是另外一门学问了，这里不多讨论）

#### 登录

这个其实是一个社会工程学和人类心理学的问题。很多人会图省事把密码设置成123456之类的东西，那么，即便你设计了再高科技的加密算法，遇到这样的弱密码一样可以被轻松攻破。

既然大家都非常讨厌密码，所以索性就不应该使用密码。常见的解决方案有如下几个：短信验证码、邮箱验证码、第三方登录（QQ、微信等）以我们公司目前出品的产品为例，我们已经没有使用用户名密码进行登录的软件了，全部都转向了短信验证码、第三方登录等功能。要想绕过第三方应用再来破解登录，其实就已经大大提高了网络攻击的成本了。

#### 访问

这一个部分非常非常重要重要的概念。我们之前提到JWT有一个非常重要的特性，就是附带身份信息。通常来说，我们会设计这样的一个api：

``` http
// 我上文用到过这个例子，现在来呼应一下
GET /api/user/getUserInfo?userId=xxxx
```

这个方法其实看似很正确，但实际上有大漏洞（假定我们没有按照JWT来设计合理的安全措施）。只要我能够获得那个人的userId，我就有办法把这个人的个人信息给扒出来。这个就是完全不设防的后果，任何人都可以随意调用接口，将会是非常危险的行为。

但是，很多时候就会犯一个错误，看如下的示例：

``` http
GET /api/user/getUserInfo?userId=xxxx

Authorization xxxxxxxx
```

我的确加上了jwt，而且没有登录的人，也不可以访问这个接口。看起来似乎很完美，但实际上这个接口跟上面的接口一样危险，完全就没有起到设防的效果。

假设我现在用userId = 1的账户登录了，然后去调用接口的时候，我填入userId = 2。此时就发生了“越权”的行为，你不仅可以获取user2的信息，而且，甚至还是冠冕堂皇地“合法”地获取了。这样子设计的接口，跟第一种比，一样危险，甚至更加可笑。下面看正确的做法：

##### 用JWT替代身份信息

其实做到第二步的时候，很多人估计已经想到了，如果我此时去解析JWT中附带的身份信息，如果不是user2的信息，那么我就不允许它访问不就好了呗？事实如此，最正确的方案就是，将所有涉及到userId，userGuid之类的身份唯一标识的地方，替换成JWT，就对了。

``` http
GET /api/user/getUserInfo

Authorization xxxxxxxx
```

表面上看，我好像没有把userId信息传进去，但实际上，在JWT中早就已经附带了你的身份信息，你无需在接口中添加专门的参数了。这样做的好处是，如果userId = 1的账户登录之后，肯定没有办法去获取userId = 2的那位用户的信息~~（前提是没有别的破解手段的情况下，不要抬杠，世界上没有100%的安全）~~，这样的设计，就已经彻底杜绝越权的可能了。