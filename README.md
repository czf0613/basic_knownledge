# 代码规范集
这里介绍了我们团队里最基本的技术框架与代码规范集合，欢迎大家借鉴和添砖加瓦。我们作为一家有着一定规模的软件公司在进行开发的时候，必然会面临团队协作以及工作交接的问题，如果没有一个稳定且规范的行为与习惯，将会给团队带来灾难。因此，根据以往的经验~~（错误示范）~~定立了如下的一些规则，并且这些规则还在不断地扩大与完善中。

如果您有着不同的想法或者疑问，非常欢迎向我们提交PR或者issue，我们会予以回复。

## 本仓库内文档的阅读顺序：

### 1，本篇README

在这篇README中，我们主要介绍了我们出品软件的技术框架以及项目选型，如果我们使用到的技术栈和您有所交集，那么相关的经验分享将不容错过～

### 2，“通识”文件夹

这里面介绍的是一些我们团队内部的通识行为，也就是说，我们在团队内部默认的一些知识储备以及行为方式，我们会在这个文件夹中列出。所谓的“通识”可能分为不同的细分领域，具体的工作会有一些不同，举个例子来说，做App开发的同事，就不一定非得要掌握Linux基本命令的知识。

### 3，对应语言/平台的子文件夹

阅读完通识目录后，就可以查看我们的详细的代码规范与文档了，相信有了之前的基础知识后，就可以更加方便地理解我们设计的思路以及做法。

## 常见技术栈选型：

我们出品的服务主要包含：安卓App，iOS App，Web后端，网页，桌面应用程序（三大平台），微信小程序以及其它程序。基本上涵盖日常生活中的所有领域的服务，那么我们将针对如上的平台挨个进行技术选型说明。

我们使用的编程语言相对来讲比较偏门，具体的用处请查看下表（其中部分语言由于使用较少并未完全列出）。语言选型没有完全的好坏之分，请不要进行拉踩，我们做出如下的选择也有一些我们的考虑。

| 编程语言                | OS/运行环境  | 用途                                               |
| ----------------------- | ------------ | -------------------------------------------------- |
| C#                      | Docker Linux | Web服务端                                          |
| Kotlin                  | Android 7.0+ | 安卓原生App                                        |
| C or C++                |              | OpenCV、Android NDK、openSSL                       |
| Swift                   | iOS, macOS   | 苹果家的产品                                       |
| Objective-C（较少用）   | iOS, macOS   | Swift和C家族语言的胶水，基本上处于半淘汰状态       |
| JavaScript / TypeScript |              | 主要用于Vue3框架中（不止用于网页）、微信小程序     |
| Rust                    |              | Desktop App中用于给WebView提供原生能力（请见下文） |

是的，你没有看错，我们在若干年前的改革中已经彻底抛弃了Java技术栈。所以除了安卓平台之外，我们已经完全不再使用Java相关的框架，如果您是想来寻找Java相关资料的，可能要失望了。

此外，因为用户体验的原因，我们并不在公司内部大范围使用诸如Flutter、ReactNative之类的应用来构建跨平台移动应用程序，因为它们的使用体验都远远赶不上原生的应用，因此短期内它们不会成为开发移动App的主力。但是在桌面应用程序上我们会使用类似的跨平台解决方案，具体的下文会说到。

### Web服务端

因为我们已经完全弃用Java的技术栈，因此我们的这个技术选型会比较特殊。我们经常使用的组件如下：

| 框架 / 软件名           | 版本限制 | 用途                             |
| ----------------------- | -------- | -------------------------------- |
| Asp.Net Core            | 6.0 LTS  | 用于构建最基础的Web服务器        |
| Entity Framework Core   | 6.0 LTS  | 进行最基本的CRUD操作             |
| Asp.Net Core Jwt Bearer |          | 进行jwt有关的操作                |
| MySQL                   | 8.0 +    | 数据库服务                       |
| Redis                   |          | KV存储服务                       |
| RabbitMQ                |          | 消息队列服务                     |
| grpc-dotnet             |          | 用于在Asp.Net Core中添加Grpc服务 |
| openResty               | 1.20+    | 网关组件（相当于Nginx的角色）    |

### Android App

安卓平台的历史包袱比较重，所以我们没有办法做到非常好的前向兼容，我们只能保证在安卓7.0及以后的平台上运行。而且由于我们的技术选型和语言选择非常激进，所以对开发人员的Kotlin水平要求非常高。并且在安卓App里，我们是禁止使用Java的，因为我们用到了很多Kotlin的特有属性，会导致这两门语言无法可靠地进行互操作。

因此，在进行开发之前，我们需要进行Kotlin语言的特训，以形成一个函数式编程的思想。注意，请不要把Java的风格或使用习惯带入Kotlin代码中，这个会严重影响Kotlin代码的质量。

同时，由于安卓平台的apk面临非常严重的安全性问题（破解、反编译），我们很多时候需要用到jni技术，将一些高敏感度的内容插入到C++程序中，以增加破解和反编译的难度，这个会在后面的详细文档中予以说明。

常用的框架/软件包罗列如下（不完整）：

| 框架 / 库名              | 要求                                                         | 作用                                                         |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Jetpack Compose          | （请见后面的文档详细说明）如非必要，我们在安卓App中不应该再使用旧的UI框架 | 一个响应式的UI框架，用Kotlin语言完成所有的界面声明、布局等等功能。 |
| Room                     | 本地保存的数据库应当进行加密操作（具体手段见“通识”文件夹中的说明） | 一个封装SQLite的数据库查询框架                               |
| coil                     | 使用coil配合compose用于加载和缓存图片，如非必要，请勿使用其它图片加载框架 | 一个有“谷歌”背景的加载、缓存和显示网络图片的框架，类似于Glide |
| jetpack datastore-pb     | 必须使用基于protobuf序列化的版本，用于完全替代SharedPreferences | 一个类型安全的SharedPreferences替代品                        |
| okhttp                   | 必须封装进去单例类里面使用，因为这个对象很重                 | http请求库                                                   |
| wire                     |                                                              | protobuf与grpc的Kotlin库（非官方，但是pure Kotlin）          |
| coroutine                | （非常重要，详见后面说明）                                   | （彻底干掉handler和回调，详见后面说明）                      |
| kotlin.serilization.json | （虽说是官方库，但是有坑，详见说明）不要使用基于Java的json库，例如gson和fastjson之类的 | kotlin json序列化的官方库                                    |
| jni                      | 详见安卓和C++相关代码说明                                    | 保护我们的程序和高性能需求                                   |

### iOS/ipadOS/macOS

因为苹果的UI框架也正处于一个技术过渡期，因此我们必须掌握两套常见框架的知识来处理日常的开发任务，即UIKit与SwiftUI。目前SwiftUI已经更新了很多个大版本，基本上已经可以覆盖大部分日常的需求了，因此我们以后开发的App都会全程使用SwiftUI框架，在不得已的情况下才会使用一些UIKit组建来做一些补充。

虽然我们不强行要求掌握OC方面的知识，并且我们目前技术栈中也在极力地去除Objective-C以及Objective-C++的部份，但是鉴于目前苹果底层架构以及组成的机制，Objective-C尚不太可能完全走出历史舞台，而是可能转换为另一个角色——Swift与原生C的胶水。这个已经在我们投入生产的项目中得到应验，OC和OC++将会编程Swift利用C语言与C++的一个桥梁，它的作用也是相当重要的。

当然也因为苹果公司的技术路线相对来说比较激进，而且Swift语言本身也存在非常非常多的特性，因此我们强烈建议在上手进行Swift语言编程之前，要牢牢掌握C/C++的基础知识以及任意一门“现代”的编程语言（例如Kotlin，C#之类的），否则Swift中的很多特性将非常难以理解，以至于写出很多难以察觉和处理的Bug，包括但不限于如下：Swift自动内存管理、闭包、异步等等。

以下是一些常用的库/组件：

| 名称        | 要求                            | 用途                                               |
| ----------- | ------------------------------- | -------------------------------------------------- |
| SwiftUI     | （在章节中细讲）                | 新时代的UI框架                                     |
| UIKit       | （在章节中细讲）                | 与SwiftUI互为补充，构建UI系统                      |
| Realm       | （在章节中细讲）                | 一个优秀的本地数据库，作为CoreData和SQLite的替代品 |
| SwiftDate   | 掌握时区的概念与ISO8601         | Swift中的时间处理库，非常方便                      |
| SwiftUIX    | 与SwiftUI一致                   | SwiftUI的补充，封装了很多常用的UIKit组件           |
| grpc-swift  | 熟练掌握Swift异步与异常处理机制 | 官方的grpc实现库，用于实现前后端通信               |
| SDWebImage  | 见下方补充1                     | SwiftUI与UIKit常用的图片缓存/加载框架              |
| URLSession  | 见下方补充2                     | http网络框架                                       |
| Codable协议 | 见下方补充2                     | 序列化、反序列化                                   |

1，在iOS 14+的系统中，苹果官方已经提供了AsyncImage组件用于加载在线图片。除了缓存图片之外，AsyncImage已经可以完全平替SDWebImage的功能了，因此我们现在也在逐步地灰度使用AsyncImage来替代某些SDWebImage使用的场合，大概率在以后的某个时间点，AsyncImage很有可能会完全替代SDWebImage。

2，鉴于苹果已经完善了http请求以及json解析的第三方库，因此我们在项目中不应该再使用相关的第三方库了，例如AFNetwork或Alamofire等等。现在的URLSession已经完成了异步化的改进，因此只需要经过少量封装，就可以实现出一个稳定高效的HttpClient。同样的道理还有json序列化，现在只需要让自定义对象服从Codable协议，即可原生支持json序列化，不需要任何第三方库。

### 桌面应用程序

按照目前的市场行情来看，我们基本上已经很少制作桌面级的应用程序了，只有少部份的专业应用、行业应用还需要使用到相关的桌面程序。而且由于桌面应用程序相对来说技术比较封闭，不太好开发彻底的跨平台应用程序，因此我们只保留了比较少的技术栈用来实现桌面App。

传统上来说，桌面应用程序分为三大主流平台，分别是Windows、macOS与Linux（暂时不考虑处理器指令集的差异，一方面来说，非主流的指令集市场占比很小，而且几乎普通用户完全不会接触到）如果要开发原生的桌面应用，三个平台的技术选型分别就是：WPF、AppKit、Qt。这三种技术基本上都很一言难尽，不是很合适的技术选型：

WPF强行绑定Windows，基本上很难在别的平台上面运行；AppKit更加是苹果专属，几乎没有可能在别的平台运行；Qt虽然是完全跨平台的解决方案，但是Qt的主流编程语言为C++，是一个非常不友好的语言，因此我们也必须放弃这个技术选型。

因此我们主流的出品将要结合程序的开发难度、移植性、运行效率进行综合考虑，筛选出了一个目前唯一的技术方案，也就是Tauri（可以理解为一个Webview + Rust提供本地能力的框架）在使用这个框架的情况下，几乎我们很少涉及到Rust的编程，因为绝大部分东西都可以靠Webview完成，仅有很小一部分程序不得不使用Rust利用本地能力。目前来说，这个框架我们使用的次数实在太少，暂未对此领域有非常明确的编程指导，我们会在日后进行完善。

### 网页/类网页运行时

这里涵盖了几个主流的应用，一个是网页，另一个是上面桌面应用程序里面提到的Webview，以及我们现在日益增长的小程序。小程序的板块会单独拿出来讲，因此本篇的前半部分只针对网页和Webview的应用。

#### 常用库（不含UI）

| 名称      | 用途                     | 注意事项                                                     |
| --------- | ------------------------ | ------------------------------------------------------------ |
| crypto-js | 处理前端的哈希与加密     | 注意其引入方式与编码方式，避免和后端产生冲突                 |
| dayjs     | 处理时间                 | 如果在使用Element-Plus的情况下，无需额外引入，因为Element-Plus已经包含 |
| dexie     | 在浏览器中读写indexed db | （非常规需求，除非必要请尽量不要在浏览器中大量保存数据）     |
| axios     | 处理网络请求             | 这是一个封装得非常好的网络请求库，但是请遵守W3C中的HTTP Method规范，这个会在后端的接口定义中提及，避免产生浏览器根本无法发出的请求 |

#### 网页/Webview

我们目前的技术方案有且只有Vue3 + Vue Router + Element-Plus + Vite + js。无论其搭配是否是最优解与否，我们都强行规定这样处理，以下是我们的一些理由。因为在接下来的若干时间内，Vue3 + Vue Router + Vite一定是Vue官方的主推搭配，webpack早就应该被扫出去了。

目前的相对稳定且活跃的UI框架，国内也就基本上只有Element-Plus可选了，因此我们只选用它作为UI框架。当然，Element-Plus自身的设计也相当不错，基本上覆盖了我们所有的常用需求。

其中最大的争议无非是js，因为现在的ts已经非常普及，越来越多的框架都在积极适配ts。但是我们选用js有一些技术考虑，大概有如下的考虑：一方面，浏览器对js一定有原生支持，因此短期内无需担心js被淘汰的问题，而且也几乎无需担心适配问题；另一方面，目前市面上绝大多数的第三方库依然是用js编写的，因此使用js能够最大程度保证它的兼容性；最后一方面则是出于灵活度的考虑，因为前端的数据处理（以及http请求）大量依赖json，这是一个极其动态化的特性，如果使用ts之后将会大大增加这方面的麻烦。

综合以上考虑，我们对网页类型的数据选型做出这样的选择。

#### 小程序（特指微信小程序）

毕竟别的App下的小程序开发基本上不入主流，因此小程序如无特殊说明都特指微信小程序。

~~由于微信的不作为以及各种屑问题，小程序开发基本上可以说是捏着鼻子在做（臭不可闻）。~~小程序主要有以下几个问题，导致它的开发基本上和网页开发其实是两码事：

##### 1，小程序虽然是js编写，但是js标准还是一个迷。

有传闻称小程序js基于es5规范，也有传闻称能支持es6，但是从我们的开发经历来看，基本上来说，小程序并不支持比较新的js语法特性，所以大家可以把它当成是一个被阉割过功能的es5来用。即，不支持Promise，不支持async/await，也不支持Proxy特性。

##### 2，缺乏双向绑定能力

基本上可以确定的是，wxml和data的绑定是单向的（虽然官方声称可以是双向，但实际进行测试的时候有各种问题），因此很多的写法不可以像Vue那样完全的mvvm，这个是特别需要注意的，否则很可能在不知道的情况下搞出来意外bug。

##### 3，wxml组件的表现问题

切勿直接把wxml的标签直接当成是webkit中的组件，他们有很多属性不通用，具体的请看微信开发文档，此处列举最严重的一个，即image标签。image标签能支持的图片类型是有限制的，且安卓平台与iOS表现并不一致，尤其注意，请勿在小程序中使用webp图片。

##### 4，尽量遵守微信的开发规范

虽然我们能在网上看到各种第三方库用来扩展小程序的网络请求、Promise之类的特性，但是为避免可能出现的审核问题，我们开发规范里面并不建议去违反相关的操作，而是使用微信官方给出的API。倒不是因为微信的API会更好，只是为了规避可能存在的合规性问题，故而做出相关约束。

## 其他技术选型

我们公司仍有少量其他技术选型，但是因为它们要么处于淘汰边缘，要么出于一些现实原因被迫进行选择，因此不在此处进行详细描述，大概有以下的几个：python、Go、Node、Spring、Ktor
